import importlib
import inspect
import sys
import textwrap
import typing
import warnings
from contextlib import contextmanager
from typing import Any, Iterable, Sequence, Set, Type

from typing_extensions import get_args, get_origin, get_type_hints


def get_subclass_methods(cls: Type[Any]) -> Set[str]:
    """Return the set of method names defined (only) on a subclass."""
    all_methods = set(dir(cls))
    base_methods = (dir(base()) for base in cls.__bases__)
    return all_methods.difference(*base_methods)


def _format_module_str(text: str, is_pyi=False) -> str:
    """Apply black and isort formatting to text."""
    try:
        import isort.api

        text = isort.api.sort_code_string(
            text, profile="black", float_to_top=True
        )
    except ImportError:
        pass

    try:
        import black

        text = black.format_str(
            text, mode=black.FileMode(line_length=79, is_pyi=is_pyi)
        )
    except ImportError:
        pass

    return text.replace("NoneType", "None")


def _generate_object_stubs(
    objects: Iterable[Any], output_file=None, imports: Sequence[str] = ()
) -> str:
    """Generat type stubs for a sequence of `objects`."""

    pyi = '# flake8: noqa\n'
    pyi += "\n".join(imports) + "\n"
    for obj in objects:
        pyi += f'def {obj.__name__}{inspect.signature(obj)}:\n'
        pyi += (
            textwrap.indent(f'"""{obj.__doc__}"""', '    ') + "\n"
            if obj.__doc__
            else '    ...\n'
        )

    pyi = _format_module_str(pyi.replace("NoneType", "None"), is_pyi=True)

    if output_file:
        with open(output_file, 'w') as f:
            f.write(pyi)

    return pyi


def _generate_cls_stubs(
    cls, output_file=None, imports: Sequence[str] = ()
) -> str:
    """Generate pyi-format type stubs for a class."""

    bases = ", ".join(f'{b.__module__}.{b.__name__}' for b in cls.__bases__)

    pyi = '# flake8: noqa\n'
    pyi += "\n".join(imports) + "\n"
    pyi += f'class {cls.__name__}({bases}):\n'

    methods = []
    for methname in sorted(get_subclass_methods(cls)):
        meth = getattr(cls, methname)
        if callable(meth):
            mstr = f"def {methname}{inspect.signature(meth)}:"
            if meth.__doc__:
                mstr += textwrap.indent(f'"""{meth.__doc__}"""', '    ') + "\n"
            else:
                mstr += '    ...\n'

            methods.append(mstr)

    pyi += textwrap.indent("\n".join(methods), '    ')
    pyi = pyi.replace("NoneType", "None")

    pyi = _format_module_str(pyi.replace("NoneType", "None"), is_pyi=True)

    if output_file:
        with open(output_file, 'w') as f:
            f.write(pyi)

    return pyi


PYI_TEMPLATE = """
# THIS FILE IS AUTOGENERATED BY napari.utils.stubgen
# DO NOT EDIT
# flake8: noqa

from typing import *
{imports}

{body}
"""


def _guess_exports(module, exclude=()):
    return [
        k
        for k, v in vars(module).items()
        if callable(v) and not k.startswith("_") and k not in exclude
    ]


def iter_imports(hint):
    # inspect.formatannotation strips "typing." from type annotations
    # so our signatures won't have it in there
    if not repr(hint).startswith("typing."):
        if orig := get_origin(hint):
            yield orig.__module__
    for arg in get_args(hint):
        yield from iter_imports(arg)
    if getattr(hint, '__module__', None) != 'builtins':
        yield hint.__module__


def generate_function_stub(func):
    sig = inspect.signature(func)
    hints = get_type_hints(func)
    sig = sig.replace(
        parameters=[
            p.replace(annotation=hints.get(p.name, p.empty))
            for p in sig.parameters.values()
        ]
    )
    imports = set()
    for hint in hints.values():
        imports.update(set(iter_imports(hint)))
    imports -= {'typing'}

    doc = f'"""{func.__doc__}"""' if func.__doc__ else '...'
    return imports, f'def {func.__name__}{sig}:\n\t{doc}'


def generate_module_stubs(module, save=True):
    if isinstance(module, str):
        module = importlib.import_module(module)

    if hasattr(module, '__all__'):
        names = module.__all__
    else:
        names = _guess_exports(module)
        warnings.warn(
            f'Module {module.__name__} does not provide `__all__`. '
            'Guessing exports.'
        )

    to_stub = (getattr(module, name) for name in names)
    imports, defs = zip(*(generate_function_stub(func) for func in to_stub))
    imports = {item for sublist in imports for item in sublist}
    _imports = "\n".join(f'import {n}' for n in imports)
    pyi = PYI_TEMPLATE.format(imports=_imports, body='\n'.join(defs))
    pyi = _format_module_str(pyi)
    if save:
        print("write to", module.__file__.replace(".py", ".pyi"))
        with open(module.__file__.replace(".py", ".pyi"), 'w') as f:
            f.write(pyi)
    return pyi


# @contextmanager
# def type_checking_true():
#     old, typing.TYPE_CHECKING = typing.TYPE_CHECKING, True
#     try:
#         yield
#     finally:
#         typing.TYPE_CHECKING = old


# def import_module_with_type_checking(module_name):
#     with type_checking_true():
#         mod = sys.modules.get(module_name, None)
#         if mod is None:
#             mod = importlib.import_module(module_name)
#         elif 'TYPE_CHECKING' in dir(mod):  # ...excludes typing.TYPE_CHECKING
#             mod = importlib.reload(mod)
#     return mod


# def really_get_type_hints(obj):
#     from typing_extensions import get_type_hints

#     if hasattr(obj, '__module__'):
#         import_module_with_type_checking(obj.__module__)
#     return get_type_hints(obj)

if __name__ == '__main__':
    import sys

    for module in sys.argv[1:]:
        generate_module_stubs(module)
