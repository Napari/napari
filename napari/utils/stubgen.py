import inspect
import textwrap
import warnings
from typing import Any, Iterable, Sequence, Set, Type


def get_subclass_methods(cls: Type[Any]) -> Set[str]:
    """Return the set of method names defined (only) on a subclass."""
    all_methods = set(dir(cls))
    base_methods = (dir(base()) for base in cls.__bases__)
    return all_methods.difference(*base_methods)


def _format_module_str(text: str, is_pyi=False) -> str:
    """Apply black and isort formatting to text."""
    try:
        import isort.api

        text = isort.api.sort_code_string(
            text, profile="black", float_to_top=True
        )
    except ImportError:
        pass

    try:
        import black

        text = black.format_str(
            text, mode=black.FileMode(line_length=79, is_pyi=is_pyi)
        )
    except ImportError:
        pass

    return text


def _generate_object_stubs(
    objects: Iterable[Any], output_file=None, imports: Sequence[str] = ()
) -> str:
    """Generat type stubs for a sequence of `objects`."""

    pyi = '# flake8: noqa\n'
    pyi += "\n".join(imports) + "\n"
    for obj in objects:
        pyi += f'def {obj.__name__}{inspect.signature(obj)}:\n'
        pyi += (
            textwrap.indent(f'"""{obj.__doc__}"""', '    ') + "\n"
            if obj.__doc__
            else '    ...\n'
        )

    pyi = _format_module_str(pyi.replace("NoneType", "None"), is_pyi=True)

    if output_file:
        with open(output_file, 'w') as f:
            f.write(pyi)

    return pyi


def _generate_cls_stubs(
    cls, output_file=None, imports: Sequence[str] = ()
) -> str:
    """Generate pyi-format type stubs for a class."""

    bases = ", ".join(f'{b.__module__}.{b.__name__}' for b in cls.__bases__)

    pyi = '# flake8: noqa\n'
    pyi += "\n".join(imports) + "\n"
    pyi += f'class {cls.__name__}({bases}):\n'

    methods = []
    for methname in sorted(get_subclass_methods(cls)):
        meth = getattr(cls, methname)
        if callable(meth):
            mstr = f"def {methname}{inspect.signature(meth)}:"
            if meth.__doc__:
                mstr += textwrap.indent(f'"""{meth.__doc__}"""', '    ') + "\n"
            else:
                mstr += '    ...\n'

            methods.append(mstr)

    pyi += textwrap.indent("\n".join(methods), '    ')
    pyi = pyi.replace("NoneType", "None")

    pyi = _format_module_str(pyi.replace("NoneType", "None"), is_pyi=True)

    if output_file:
        with open(output_file, 'w') as f:
            f.write(pyi)

    return pyi


PYI_TEMPLATE = """
# THIS FILE IS AUTOGENERATED.  DO NOT EDIT
# flake8: noqa

from typing import *
{imports}

{body}
"""

from typing import get_type_hints

from typing_extensions import get_type_hints


def _guess_exports(module, exclude=()):
    return [
        k
        for k, v in vars(module).items()
        if callable(v) and not k.startswith("_") and k not in exclude
    ]


def generate_function_stub(func):
    sig = inspect.signature(func)

    doc = f'"""{func.__doc__}"""' if func.__doc__ else '...'
    types = [
        p.annotation
        for p in sig.parameters.values()
        if p.annotation is not p.empty
    ]
    if sig.return_annotation is not sig.empty:
        types.append(sig.return_annotation)
    imports = [t for t in types]
    return imports, f'def {func.__name__}{sig}:\n\t{doc}'


def fixup(pyi):
    try:
        import black

        pyi = black.format_str(
            pyi, mode=black.FileMode(line_length=79, is_pyi=True)
        )
    except ImportError:
        pass
    return pyi.replace("NoneType", "None")


def generate_module_stubs(module):
    output = module.__file__.replace(".py", ".pyi")

    if hasattr(module, '__all__'):
        names = module.__all__
    else:
        names = _guess_exports(module)
        warnings.warn(
            f'Module {module.__name__} does not provide `__all__`. '
            'Guessing exports.'
        )

    to_stub = (getattr(module, name) for name in names)
    defs = (generate_function_stub(func) for func in to_stub)

    pyi = PYI_TEMPLATE.format()
    with open(output, 'w') as f:
        f.write(fixup(pyi))


import importlib
import inspect
import sys
import typing
from contextlib import contextmanager


@contextmanager
def type_checking_true():
    old, typing.TYPE_CHECKING = typing.TYPE_CHECKING, True
    try:
        yield
    finally:
        typing.TYPE_CHECKING = old


def import_module_with_type_checking(module_name):
    with type_checking_true():
        mod = sys.modules.get(module_name, None)
        if mod is None:
            mod = importlib.import_module(module_name)
        elif 'TYPE_CHECKING' in dir(mod):  # ...excludes typing.TYPE_CHECKING
            mod = importlib.reload(mod)
    return mod


def really_get_type_hints(obj):
    from typing_extensions import get_type_hints

    import_module_with_type_checking(obj.__module__)
    return get_type_hints(obj)
